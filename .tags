!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ALGORITHM_H_	algorithm.h	7;"	d
Algorithm	algorithm.h	/^class Algorithm {$/;"	c
FCFS	FCFS.cpp	/^FCFS::FCFS(vector <Process*> in_prcs, int in_n, int c_s) {$/;"	f	class:FCFS
FCFS	FCFS.h	/^class FCFS : public Algorithm{$/;"	c
FCFS_H_	FCFS.h	8;"	d
PRIORITY	PRIORITY_NONP.cpp	/^PRIORITY::PRIORITY(vector <Process*> in_prcs, int in_n, int c_s) {$/;"	f	class:PRIORITY
PRIORITY	PRIORITY_NONP.h	/^class PRIORITY : public Algorithm{$/;"	c
PRIORITY_H_	PRIORITY_NONP.h	9;"	d
PROCESS_H_	process.h	2;"	d
PRR	PRR.cpp	/^PRR::PRR(vector <Process*> in_prcs, int in_n, int c_s) {$/;"	f	class:PRR
PRR	PRR.h	/^class PRR : public Algorithm{  $/;"	c
PRR_H_	PRR.h	10;"	d
Process	process.h	/^typedef struct process Process;$/;"	t	typeref:struct:process
QUANTUM	PRR.h	11;"	d
ROUNDR	ROUND_ROBIN.cpp	/^ROUNDR::ROUNDR(vector <Process*> in_prcs, int in_n, int c_s) {$/;"	f	class:ROUNDR
ROUNDR	ROUND_ROBIN.h	/^class ROUNDR : public Algorithm {$/;"	c
ROUNDR_H_	ROUND_ROBIN.h	11;"	d
SJF	SJF.cpp	/^SJF::SJF(vector <Process*> in_prcs, int in_n, int ctx) {$/;"	f	class:SJF
SJF	SJF.h	/^class SJF : public Algorithm{  $/;"	c
SJF2	SJF_NONP.cpp	/^SJF2::SJF2(vector <Process*> in_prcs, int in_n, int c_s) {$/;"	f	class:SJF2
SJF2	SJF_NONP.h	/^class SJF2 : public Algorithm{$/;"	c
SJF2_H_	SJF_NONP.h	9;"	d
SJF_H_	SJF.h	10;"	d
arrival_time	process.h	/^      arrival_time,$/;"	m	struct:process
burst_time	process.h	/^      burst_time,$/;"	m	struct:process
calculateRT	FCFS.cpp	/^void FCFS::calculateRT() {$/;"	f	class:FCFS
calculateRT	SJF.cpp	/^void SJF::calculateRT() {$/;"	f	class:SJF
calculateTAT	FCFS.cpp	/^void FCFS::calculateTAT() {$/;"	f	class:FCFS
calculateTAT	SJF.cpp	/^void SJF :: calculateTAT()$/;"	f	class:SJF
calculateWT	FCFS.cpp	/^void FCFS::calculateWT() {$/;"	f	class:FCFS
calculateWT	SJF.cpp	/^void SJF :: calculateWT(){ $/;"	f	class:SJF
cambios	SJF.cpp	/^int cambios = 0;$/;"	v
cambios	SJF.h	/^        cambios = 0,$/;"	m	class:SJF
chan	SJF.h	/^        chan;$/;"	m	class:SJF
compareArrival	algorithm.cpp	/^bool Algorithm::compareArrival(Process *p1, Process *p2) {$/;"	f	class:Algorithm
comparePID	algorithm.cpp	/^bool Algorithm::comparePID(Process *p1, Process *p2) {$/;"	f	class:Algorithm
compareST	algorithm.cpp	/^bool Algorithm::compareST(Process *p1, Process *p2) {$/;"	f	class:Algorithm
completation_time	process.h	/^      completation_time,$/;"	m	struct:process
context_switch	PRR.h	/^        context_switch;$/;"	m	class:PRR
context_switch	algorithm.h	/^    int context_switch;$/;"	m	class:Algorithm
copyProcess	scheduling.cpp	/^void copyProcess(vector <Process*> th_ps, vector <Process*> *th_pd) {$/;"	f
execute	FCFS.cpp	/^void FCFS::execute() {$/;"	f	class:FCFS
execute	PRIORITY_NONP.cpp	/^void PRIORITY::execute() {$/;"	f	class:PRIORITY
execute	PRR.cpp	/^void PRR::execute() {$/;"	f	class:PRR
execute	ROUND_ROBIN.cpp	/^void ROUNDR::execute() {$/;"	f	class:ROUNDR
execute	SJF.cpp	/^void SJF :: execute()$/;"	f	class:SJF
execute	SJF_NONP.cpp	/^void SJF2::execute() {$/;"	f	class:SJF2
fcfsTHREAD	scheduling.cpp	/^void fcfsTHREAD(vector <Process*> p, int n_p, int c_s) {$/;"	f
main	scheduling.cpp	/^int main() {$/;"	f
menu	scheduling.cpp	/^void menu(int opt) {$/;"	f
nCambios	SJF.cpp	/^int nCambios[2000];$/;"	v
nCambios	SJF.h	/^        nCambios[2000],$/;"	m	class:SJF
n_prcs	FCFS.h	/^    int n_prcs;$/;"	m	class:FCFS
n_prcs	PRIORITY_NONP.h	/^    int n_prcs;$/;"	m	class:PRIORITY
n_prcs	PRR.h	/^    int n_prcs,$/;"	m	class:PRR
n_prcs	ROUND_ROBIN.h	/^    int n_prcs;$/;"	m	class:ROUNDR
n_prcs	SJF.h	/^    int n_prcs,$/;"	m	class:SJF
n_prcs	SJF_NONP.h	/^    int n_prcs;$/;"	m	class:SJF2
p_id	process.h	/^  int p_id,$/;"	m	struct:process
prcs	FCFS.h	/^    vector <Process*> prcs;$/;"	m	class:FCFS
prcs	PRIORITY_NONP.h	/^    vector <Process*> prcs;$/;"	m	class:PRIORITY
prcs	PRR.h	/^    vector <Process*> prcs;$/;"	m	class:PRR
prcs	ROUND_ROBIN.h	/^    vector <Process*> prcs;$/;"	m	class:ROUNDR
prcs	SJF.h	/^    vector <Process*> prcs;$/;"	m	class:SJF
prcs	SJF_NONP.h	/^    vector <Process*> prcs;$/;"	m	class:SJF2
printGantt	algorithm.cpp	/^void Algorithm::printGantt(Process p[], int n_prcs) {$/;"	f	class:Algorithm
printGanttSJF	SJF.cpp	/^void SJF::printGanttSJF(vector <Process*> p, int n_prcs) {$/;"	f	class:SJF
printGanttV2	algorithm.cpp	/^void Algorithm::printGanttV2(vector <Process*> p, int n_prcs) {$/;"	f	class:Algorithm
priority	process.h	/^      priority;$/;"	m	struct:process
priorityTHREAD	scheduling.cpp	/^void priorityTHREAD(vector <Process *> p, int n_p, int c_s) {$/;"	f
process	process.h	/^struct process {$/;"	s
response_time	process.h	/^      response_time,$/;"	m	struct:process
roundrTHREAD	scheduling.cpp	/^void roundrTHREAD(vector <Process *> p, int n_p, int c_s) {$/;"	f
selectAlgorithm	scheduling.cpp	/^void selectAlgorithm(int opt, vector <Process*> p_base, int n_prcs, int context_switch) {$/;"	f
sjfTHREAD	scheduling.cpp	/^void sjfTHREAD(vector <Process*> p, int n_p, int c_s) {$/;"	f
start_time	process.h	/^      start_time,$/;"	m	struct:process
tCambios	SJF.cpp	/^int tCambios[2000];$/;"	v
tCambios	SJF.h	/^        tCambios[2000],$/;"	m	class:SJF
total_idle_time	algorithm.h	/^        total_idle_time = 0;$/;"	m	class:Algorithm
total_response_time	algorithm.h	/^        total_response_time = 0,$/;"	m	class:Algorithm
total_turnaround_time	algorithm.h	/^    double total_turnaround_time = 0,$/;"	m	class:Algorithm
total_waiting_time	algorithm.h	/^        total_waiting_time = 0,$/;"	m	class:Algorithm
turnaround_time	process.h	/^      turnaround_time,$/;"	m	struct:process
waiting_time	process.h	/^      waiting_time,$/;"	m	struct:process
writeData	algorithm.cpp	/^void Algorithm::writeData(vector <Process*> prcs, int n_prcs, string file_name) {$/;"	f	class:Algorithm
